% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mfp2.R
\name{mfp2}
\alias{mfp2}
\alias{mfp2.default}
\alias{mfp2.formula}
\title{Multivariable Fractional Polynomial Models with Extensions}
\usage{
mfp2(x, ...)

\method{mfp2}{default}(
  x,
  y,
  weights = NULL,
  offset = NULL,
  cycles = 5,
  scale = NULL,
  shift = NULL,
  df = 4,
  center = TRUE,
  subset = NULL,
  family = c("gaussian", "poisson", "binomial", "Gamma", "cox"),
  criterion = c("pvalue", "aic", "bic"),
  select = 0.05,
  alpha = 0.05,
  keep = NULL,
  xorder = c("ascending", "descending", "original"),
  powers = NULL,
  ties = c("breslow", "efron", "exact"),
  strata = NULL,
  nocenter = NULL,
  acdx = NULL,
  ftest = FALSE,
  control = NULL,
  zero = NULL,
  catzero = NULL,
  spike = NULL,
  verbose = TRUE,
  ...
)

\method{mfp2}{formula}(
  formula,
  data,
  weights = NULL,
  offset = NULL,
  cycles = 5,
  scale = NULL,
  shift = NULL,
  df = 4,
  center = TRUE,
  subset = NULL,
  family = c("gaussian", "poisson", "binomial", "Gamma", "cox"),
  criterion = c("pvalue", "aic", "bic"),
  select = 0.05,
  alpha = 0.05,
  keep = NULL,
  xorder = c("ascending", "descending", "original"),
  powers = NULL,
  ties = c("breslow", "efron", "exact"),
  strata = NULL,
  nocenter = NULL,
  ftest = FALSE,
  control = NULL,
  verbose = TRUE,
  ...
)
}
\arguments{
\item{x}{for \code{mfp2.default}: \code{x} is an input matrix of dimensions
nobs x nvars. Each row is an observation vector.}

\item{...}{not used.}

\item{y}{for \code{mfp2.default}: \code{y} is a vector for the response variable.
For \code{family = "binomial"} it should be  a vector with two levels (see
\code{\link[stats:glm]{stats::glm()}}). For \code{family = "cox"} it must be a \code{\link[survival:Surv]{survival::Surv()}} object
containing 2 columns.}

\item{weights}{a vector of observation weights of length nobs.
Default is \code{NULL} which assigns a weight of 1 to each observation.}

\item{offset}{a vector of length nobs that is included in the linear
predictor. Useful for the poisson family (e.g. log of exposure time).
Default is \code{NULL} which assigns an offset  of 0 to each observation.
If supplied, then values must also be supplied to the \code{predict()} function.}

\item{cycles}{an integer, specifying the maximum number of iteration cycles.
Default is 5.}

\item{scale}{a numeric vector of length \code{nvars} or single numeric specifying
scaling factors. If a single numeric, then the value will be replicated as
necessary. The formula interface \code{mfp2.formula} only supports single numeric
input to set a default value, individual values can be set using \code{fp} terms
in the \code{formula} input.
Default is \code{NULL} which lets the program estimate the scaling factors
(see Details section). If scaling is not required set \code{scale = 1} to disable
it. The final regression coefficients are expressed in the original scale of
the data.}

\item{shift}{a numeric vector of length nvars or a single numeric specifying
shift terms. If a single numeric, then the value will be replicated as
necessary. The formula interface \code{mfp2.formula} only supports single numeric
input to set a default value, individual values can be set using \code{fp} terms
in the \code{formula} input.
Default is \code{NULL} which lets the program estimate the shifts
(see Details section). If shifting is not required, set \code{shift = 0} to
disable it.}

\item{df}{a numeric vector of length nvars or a single numeric that sets the
(default) degrees of freedom (df) for each predictor. If a single numeric,
then the value will be replicated as necessary. The formula interface
\code{mfp2.formula} only supports single numeric input to set a default value,
individual values can be set using \code{fp} terms in the \code{formula} input.
The df (not counting the intercept) are twice the degree of a fractional
polynomial (FP). For example, an FP2 has 4 df, while FPm has 2*m df.
The program overrides default df based on the number of distinct (unique)
values for a variable as follows:
2-3 distinct values are assigned \code{df = 1} (linear), 4-5 distinct values are
assigned \code{df = min(2, default)} and >= 6 distinct values are assigned
\code{df = default}.}

\item{center}{a logical determining whether variables are centered before
final model fitting. The default \code{TRUE} implies mean centering, except for
binary covariates, where the covariate is centered using the lower of the two
distinct values of the covariate. See Details section below.}

\item{subset}{an optional vector specifying a subset of observations
to be used in the fitting process. Default is \code{NULL} and all observations are
used. See Details below.}

\item{family}{a character string representing a \code{glm()} family object as well
as Cox models. For more information, see details section below.}

\item{criterion}{a character string specifying the criterion used to select
variables and FP models of different degrees.
Default is to use p-values in which case the user can specify
the nominal significance level (or use default level of 0.05) for variable and
functional form selection (see \code{select} and \code{alpha} parameters below).
If the user specifies the BIC (\code{bic}) or AIC (\code{aic}) criteria the program
ignores the nominal significance levels and selects variables and functional
forms using the chosen information criterion.}

\item{select}{a numeric vector of length nvars or a single numeric that
sets the nominal significance levels for variable selection on each predictor
by backward elimination. If a single numeric, then the value will be replicated
as necessary. The formula interface \code{mfp2.formula} only supports single numeric
input to set a default value, individual values can be set using \code{fp} terms
in the \code{formula} input. The default nominal significance level is 0.05
for all variables. Setting the nominal significance level to be 1 for
certain variables forces them into the model, leaving all other variables
to be selected.}

\item{alpha}{a numeric vector of length nvars or a single numeric that
sets the significance levels for testing between FP models of
different degrees. If a single numeric, then the value will be replicated
as necessary. The formula interface \code{mfp2.formula} only supports single numeric
input to set a default value, individual values can be set using \code{fp} terms
in the \code{formula} input. The default nominal significance level is 0.05 for all
variables.}

\item{keep}{a character vector with names of variables to be kept
in the model. In case that \code{criterion = "pvalue"}, this is equivalent to
setting the selection level for the variables in \code{keep} to 1.
However, this option also keeps the specified variables in the model when
using the BIC or AIC criteria.}

\item{xorder}{a string determining the order of entry of the covariates
into the model-selection algorithm. The default is \code{ascending}, which enters
them by ascending p-values, or decreasing order of significance in a
multiple regression (i.e. most significant first).
\code{descending} places them in reverse significance order, whereas
\code{original} respects the original order in \code{x}.}

\item{powers}{a named list of numeric values that sets the permitted FP
powers for each covariate. The default is NULL, and each covariate is assigned
\code{powers = c(-2, -1, -0.5, 0, 0.5, 1, 2, 3)}, where 0 means the natural
logarithm. Powers are sorted before further
processing in the program. If some variables are not assigned powers, the
default powers will be assigned. The formula interface offers two options
for supplying powers: through the 'powers' argument and the 'fp()' function.
So, if the user supplies powers in both options for a certain variable, the
powers supplied through 'fp()' will be given preference.For the algorithm to
select the powers, each variable must have a minimum of two powers. If the
users wants to use one power, they should first transform their variables
before using \code{mfp2()} function and specify appropriate df}

\item{ties}{a character string specifying the method for tie handling in
Cox regression. If there are no tied death times all the methods are
equivalent. Default is the Breslow method. This argument is used for Cox
models only and has no effect on other model families.
See \code{\link[survival:coxph]{survival::coxph()}} for details.}

\item{strata}{a numeric vector or matrix of variables that define strata
to be used for stratification in a Cox model. A new factor, whose levels are
all possible combinations of the variables supplied will be created.
Default is \code{NULL} and a Cox model without stratification would be fitted.
See \code{\link[survival:coxph]{survival::coxph()}} for details.}

\item{nocenter}{a numeric vector with a list of values for fitting Cox
models. See \code{\link[survival:coxph]{survival::coxph()}} for details.}

\item{acdx}{a character vector of names of continuous variables to undergo
the approximate cumulative distribution (ACD) transformation.
It also invokes the function-selection procedure to determine the
best-fitting FP1(p1, p2) model (see Details section). Not present in the
formula interface \code{mfp2.formula} and to be set using \code{fp} terms in the
\code{formula} input.
The variable representing the ACD transformation of \code{x} is named \code{A_x}.}

\item{ftest}{a logical; for normal error models with small samples, critical
points from the F-distribution can be used instead of Chi-Square
distribution. Default \code{FALSE} uses the latter. This argument is used for
Gaussian models only and has no effect for other model families.}

\item{control}{a list object with parameters controlling model fit details.
Returned by either \code{\link[stats:glm.control]{stats::glm.control()}} or \code{\link[survival:coxph.control]{survival::coxph.control()}}.
Default is \code{NULL} to use default parameters for the given model class.}

\item{zero}{A character vector specifying the names of variables for which
nonpositive values should be treated as zero. This allows fitting a fractional
polynomial (FP) model using only the positive values of a covariate, while
setting nonpositive values to zero during transformation. See the \strong{Details}
section}

\item{catzero}{A character vector specifying the names of variables for which
nonpositive values should be treated as zero, similar to the \code{zero} argument.
The key difference is that \code{mfp2} will automatically create a corresponding
binary indicator variable (e.g., \code{var > 0}) and include it in the model
alongside the transformed variable. See the \strong{Details} section}

\item{spike}{A character vector specifying the continuous variables to be
assessed for a spike at zero. Supplying this argument triggers the
spike-at-zero (SAZ) algorithm (see Details). This argument is not available
in the formula interface \code{mfp2.formula}, where spike variables should instead be
specified using \code{fp} terms in the \code{formula} input.}

\item{verbose}{a logical; run in verbose mode.}

\item{formula}{for \code{mfp2.formula}: an object of class \code{formula}: a symbolic
description of the model to be fitted. Special \code{fp} terms can be used to
define fp-transformations. The details of model specification are given
under ‘Details’.}

\item{data}{for \code{mfp2.formula}: a \code{data.frame} which contains all variables
specified in \code{formula}.}
}
\value{
\code{mfp2()} returns an object of class inheriting from \code{glm} or \code{copxh},
depending on the \code{family} parameter.

The function \code{summary()} (i.e. \code{\link[=summary.mfp2]{summary.mfp2()}}) can be used to obtain or
print a summary of the results.
The generic accessor function \code{coef()} can be used to extract the vector of
coefficients from the fitted model object.
The generic \code{predict()} can be used to obtain predictions from the fitted
model object.

An object of class \code{mfp2} is a list containing all entries as for \code{glm}
or \code{coxph}, and in addition the following entries:
\itemize{
\item convergence_mfp: logical value indicating convergence of mfp algorithm.
\item fp_terms: a data.frame with information on fractional polynomial
terms.
\item transformations: a data.frame with information on shifting, scaling
and centering for all variables.
\item fp_powers: a list with all powers of fractional polynomial terms.
Each entry of the list is named according to the transformation of the
variable.
\item acd: a vector with information for which variables the acd
transformation was applied.
\item x_original: the scaled and shifted input matrix but without
transformations.
\item y: the original outcome variable.
\item x: the final transformed input matrix used to fit the final model.
\item call_mfp: the call to the \code{mfp2()} function.
\item family_string: the family stored as character string.
\item zero: named logical vector indicating, for each variable, whether only
positive values were transformed.
\item catzero: named logical vector indicating which columns in \code{x} treated
nonpositive values as zero and included an additional binary indicator in
the model.
\item spike_decision: named numeric vector with values 1, 2, or 3 specifying
spike-at-zero handling for each variable. Value 1 includes both the
transformed variable and a binary indicator, 2 disables the spike and binary
indicator, and 3 retains only the binary indicator.
}
The \code{mfp2} object may contain further information depending on family.
}
\description{
Selects the multivariable fractional polynomial (MFP) model that best predicts
the outcome variable. This function also supports approximate cumulative
distribution (ACD) transformations for continuous variables, which allow
modeling of sigmoid relationships between predictors \code{x} and the outcome \code{y}
(Royston, 2014; Royston and Sauerbrei, 2016), as well as spike-at-zero (SAZ)
modeling, which allows proper handling of semi-continuous predictors
(Lorenz et al., 2017, 2019).
This function provides two interfaces for input data: one for inputting
data matrix \code{x} and  outcome vector \code{y} directly and the other for using a
\code{formula} object together with a dataframe \code{data}. Both interfaces are
equivalent in terms of functionality.
}
\section{Methods (by class)}{
\itemize{
\item \code{mfp2(default)}: Default method using input matrix \code{x} and outcome vector \code{y}.

\item \code{mfp2(formula)}: Provides formula interface for \code{mfp2}.

}}
\section{Brief summary of FPs}{


In the following we denote fractional polynomials for a variable \eqn{x} by
increasing complexity as either FP1 or FP2. In this example,
\eqn{FP2(p1, p2)} for \eqn{p1\neq p2} is the most flexible FP transformation,
where \deqn{FP2(p1, p2) = \beta_1 x^{p1} + \beta_2 x^{p2}.}
When \eqn{p1 = p2} (repeated powers), the FP2 model is given by
\deqn{FP2(p1, p2) = \beta_1 x^{p1} + \beta_2 x^{p1}log(x).}
The powers \eqn{p1} and \eqn{p2} are usually chosen from a predefined set
of powers \eqn{S = {(-2, -1, -0.5, 0, 0.5, 1, 2, 3)}} where the power
of 0 indicates the natural logarithm. The best FP2 is then estimated by using a
closed testing procedure that seeks the best combination from all 36 pairs of
powers \eqn{(p1, p2)}. Functions that only involve a single power of
the variable are denoted as FP1, i.e.
\deqn{FP1(p1) = \beta_1 x^{p1}.}
For details, see Sauerbrei et al. (2006) and Royston & Sauerbrei (2008).
For the effects of influential points on FP functions, see Sauerbrei et al.
(2023).
}

\section{Details on \code{family} option}{


\code{mfp2()} supports the family object as used by \code{\link[stats:glm]{stats::glm()}}. The built in
families are specified via a character string. \code{mfp2(..., family = "binomial")}
fits a logistic regression model, while \code{mfp2(..., family = "gaussian")}
fits a linear regression (ordinary least squares) model.

For Cox models, the response should preferably be a \code{Surv} object,
created by the \code{\link[survival:Surv]{survival::Surv()}} function, and the \code{family = "cox"}.
Only right-censored data are currently supported. To fit stratified Cox
models, the \code{strata} option can be used, or alternatively \code{strata} terms
can be included in the model formula when using the formula interface
\code{mfp2.formula}.
}

\section{Details on shifting, scaling, centering}{


Fractional polynomials are defined only for positive variables due to the
use of logarithms and other powers. Thus, \code{mfp2()} estimates shifts for
each variables to ensure positivity or assumes that the variables are
already positive when computing fractional powers of the input variables
in case that shifting is disabled manually.

If the values of the variables are too large or too small, it is important to
conduct variable scaling to reduce the chances of numerical underflow or
overflow which can lead to inaccuracies and difficulties in estimating the
model. Scaling can be done automatically or by directly specifying the
scaling values so that the magnitude of the \code{x} values are not too extreme.
By default scaling factors are estimated by the program as follows.

After adjusting the location of \eqn{x} so that its minimum value is positive,
creating \eqn{x'}, automatic scaling will divide each value of \eqn{x'} by
\eqn{10^p} where the exponent \eqn{p} is given by
\deqn{p = sign(k) \times floor(|k|) \quad \text{where} \quad k = log_{10} (max(x')- min(x'))}

After the final FP powers are estimated, the program backscales \eqn{x'} to
the original scale \eqn{x}, ensuring that the final regression coefficients
are expressed in the original scale of the data. The FP transformation of
\eqn{x} is centered on the mean of the observed values of \eqn{x}. For example,
for the FP1 model \eqn{\beta_0 + \beta_1x^p},the actual model fitted by the
software would be \eqn{\beta'_0 + \beta'_1(x^p-mean(x^p))}. This approach
ensures that the revised constant \eqn{\beta'_0} or baseline hazard function
in a Cox model retains a meaningful interpretation.

So in brief: shifting is required to make input values positive, scaling
helps to bring the values to a reasonable range. Both operations are
conducted before estimating the FP powers for an input variable.
Centering, however, is done after estimating the FP functions for each
variable.
Centering before estimating the FP powers may result in different powers and
should be avoided. Also see \code{\link[=transform_vector_fp]{transform_vector_fp()}} for some more details.
}

\section{Details on the \code{subset} argument}{

Note that subsetting occurs after data pre-processing (shifting and scaling),
but before model selection and fitting. In detail, when the option \code{subset} is
used and scale, shift or centering values are to be estimated, then \code{mfp2()}
first estimates these parameters using the full dataset (no subsetting).
It then conduct subsetting before proceeding to perform model selection and
fitting on the specified subset of the data.

Therefore, subsetting in \code{mfp2()} is not equivalent to subsetting the data
before passing it to \code{mfp2()}, and thus cannot be used to implement, for example,
cross-validation or to remove \code{NA}. These tasks should be done by the caller
beforehand. However, it does allow to use the same data pre-processing
for different subsets of the data. An example use case is when separate
models are to be estimated for women and men in the dataset, but a common
data pre-processing should be applied. In this case the \code{subset} option
can be used to restrict model selection to either women or men, but the
data processing (e.g. shifting factors) will be shared between the two models.
}

\section{Details on  approximate cumulative distribution transformation}{


The approximate cumulative distribution (ACD) transformation (Royston 2014)
converts each predictor, \eqn{x}, smoothly to an approximation, \eqn{acd(x)},
of its empirical cumulative distribution function.
This is done by smoothing a probit transformation of
the scaled ranks of \eqn{x}. \eqn{acd(x)} could be used instead of \eqn{x}
as a covariate. This has the advantage of providing sigmoid curves, something
that regular FP functions cannot achieve.
Details of the precise definition and some possible uses of the ACD
transformation in a univariate context are given by Royston (2014).
Royston and Sauerbrei (2016) describes how one could go further and replace FP2
functions with a pair of FP1 functions, one in \eqn{x} and the other in
\eqn{acd(x)}.

This alternative class of four-parameter functions provides about
the same flexibility as the standard FP2 family, but the ACD component offers
the additional possibility of sigmoid functions.
Royston (2014) discusses how the extended class of functions known as
\eqn{FP1(p1, p2)}, namely
\deqn{FP1(p1, p2) = \beta_1 x^{p1} + \beta_2 acd(x)^{p2}}
can be fitted optimally by seeking the best combination of all 64 pairs of
powers (p1, p2). The optimisation is invoked by use of the \code{acdx} parameter.
Royston (2014) also described simplification of the chosen function through
model reduction by applying significance testing to six sub-families of
functions,M1-M6, giving models M1 (most complex) through M6 (null):
\itemize{
\item M1: FP1(p1, p2) (no simplification)
\item M2: FP1(p1, .) (regular FP1 function of \eqn{x})
\item M3: FP1(., p2) (regular FP1 function of \eqn{acd(x)})
\item M4: FP1(1, .) (linear function of \eqn{x})
\item M5: FP1(., 1) (linear function of \eqn{acd(x)})
\item M6: Null (\eqn{x} omitted entirely)
}
Selection among these six sub-functions is performed by a closed test
procedure known as the function-selection pocedure FSPA.
It maintains the family-wise type 1 error
probability for selecting \eqn{x} at the value determined by the
\code{select} parameter. To obtain a 'final' model, a structured sequence of up
to five tests is carried out, the first at the significance level specified
by the \code{select} parameter, and the remainder at the significance level
provided by the \code{alpha} option.
The sequence of tests is as follows:
\itemize{
\item Test 1: Compare the deviances of models 6 and 1 on 4 d.f.
If not significant then stop and omit \eqn{x}, otherwise continue to step 2.
\item Test 2: Compare the deviances of models 4 and 1 on 3 d.f.
If not significant then accept model 4 and stop. Otherwise, continue to step 3.
\item Test 3: Compare the deviance of models 2 and 1 on 2 d.f.
If not significant then accept model 2 and stop. Otherwise continue to step 4.
\item Test 4: Compare the deviance of models 3 and 1 on 2 d.f.
If significant then model 1 cannot be simplified; accept model 1 and stop.
Otherwise continue to step 5.
\item Test 5: Compare the deviances of models 5 and 3 on 1 d.f.
If significant then model 3 cannot be simplified; accept model 3.
Otherwise, accept model 5. End of procedure.
}
The result is the selection of one of the six models. For details see
Royston and Sauerbrei (2016).
}

\section{Details on  spike-at-zero (SAZ) modeling}{

In epidemiological and clinical studies, a continuous covariate \code{x} may have a
mixture of zeros and positive values, which is called a semi-continuous variable.
There is a ‘spike’ at zero in an otherwise continuous distribution. Examples
include occupational exposures (e.g., asbestos) or alcohol and tobacco
consumption, where some individuals have no exposure, while others have a
positive continuous exposure. When x = 0 defines a distinct subpopulation,
the outcome for these individuals can be modeled explicitly using a binary
variable \code{z}, while the positive values are modeled as a continuous variable
with a dose–response relationship.

An approach using FP functions for a spike-at-zero (SAZ) variable proceeds in
two stages.

Stage 1: Functional form selection
A binary indicator Z is created that takes the value 1 if x = 0 and 0 otherwise.
FP transformations are applied only to the positive values of x, so there is
no need to shift x.
The selection procedure proceeds sequentially as follows:
\enumerate{
\item Compare the most complex model (best FP2 + Z) with the null model:
\itemize{
\item Degrees of freedom: 5 (4 from FP2, 1 from Z)
\item If significant, continue; otherwise, choose the null model.
}
\item Compare best FP2 + Z versus linear + Z model:
\itemize{
\item Degrees of freedom: 3
\item If significant, continue; otherwise, select linear + Z.
}
\item Compare best FP2 + Z versus best FP1 + Z model:
\itemize{
\item Degrees of freedom: 2
\item If significant, retain best FP2 + Z; otherwise, select best FP1 + Z.
}
}

This ensures that the functional form is selected sequentially, retaining only
models that significantly improve fit, always including Z. Stage 1 is
identical to the standard MFP function selection process, except that \code{Z} is
forced into the model at every step.

Stage 2: Component assessment
The selected model from Stage 1 is evaluated to decide which components are
needed. For example, suppose the selected model is best FP2 + Z:
\itemize{
\item Test 1: Compare best FP2 + Z versus best FP2 alone to assess the contribution of Z.
\item Test 2: Compare best FP2 + Z versus Z alone to assess the contribution of the FP2 term.
}

Decision rules:
\itemize{
\item If both tests are significant, retain both Z and FP2 in the final model,
because each component adds information beyond the other.
\item If Test 1 is significant but Test 2 is not, retain only Z, because the
spike indicator improves the model while the functional form does not
contribute additional information.
\item If Test 2  is significant but Test 1 is not, retain only FP2, because the
functional form improves the model while the spike indicator does not add
further explanatory value.
\item If neither test is significant, compare the deviances of the Z-only and
FP2-only models. The final model is the one with the smaller deviance,
since it provides the better fit to the data without unnecessary terms.
}

If Z is removed, the spike at zero plays no specific role, and a usual FP
function is selected for the positive values of x. Conversely, if the FP
function is removed, leaving only Z in the model, the covariate's effect is
entirely represented by the binary indicator. Note that the presence of Z
in Stage 1 may have influenced the choice of FP powers, so the final powers
may differ from those obtained in a standard FP analysis.
}

\section{Handling extreme proportions of zeros in spike-at-zero (SAZ) modeling}{

The SAZ approach is only applicable if the proportion of zeros is neither too small
nor too large, typically between 5\% and 95\%. Variables with fewer than 5\% zeros may
not provide enough information to justify a separate binary term, and this threshold
may be too low for small sample sizes, where estimation of separate FP terms could be
unstable. Variables with more than 95\% zeros are mostly zeros, and the positive portion
may be too sparse for reliable estimation.

In the implementation, the \code{reset_spike} function automatically handles such
extreme cases. By default, if fewer than 5\% or more than 95\% of the values
are zero, the spike is reset to \code{FALSE}, and the variable is treated as a
standard continuous covariate. This ensures that spike-at-zero modeling is
applied only when there is sufficient information in both the zero and
positive portions of the variable.
}

\section{Details on model specification using a \code{formula}}{

\code{mfp2} supports model specifications using two different interfaces: one
which allows passing of the data matrix \code{x} and outcome vector \code{y} directly
(as done in e.g. \code{\link[stats:glm]{stats::glm.fit()}} or \code{glmnet}) and another which conforms
to the formula interface used by many commonly used R modelling functions
such as \code{\link[stats:glm]{stats::glm()}} or \code{\link[survival:coxph]{survival::coxph()}}.

Both interfaces are equivalent in terms of possible fitted models, only the
details of specification differ. In the standard interface all details
regarding FP-transformations are given as vectors. In the formula interface
all details are specified using special \code{fp()} function. These support the
specification of degrees of freedom (\code{df}), nominal significance level for
variable selection (\code{select}), nominal significance level for functional form
selection (\code{alpha}), shift values (\code{shift}), scale values (\code{scale}),
centering (\code{center}), CD-transformation (\code{acd}) and spike (\code{spike}). Values
specified through \code{fp()} function override the values specified as defaults
and passed to the \code{mfp2()} function.

The formula may also contain \code{strata} terms to fit stratified Cox models, or
an \code{offset} term to specify a model offset.

Note that for a formula using \code{.}, such as \code{y ~ .} the \code{mfp2()} function may not
fit a linear model, but may perform variable and functional form selection
using FP-transformations, depending on the default settings of \code{df},
\code{select} and \code{alpha} passed as arguments to \code{mfp2()}.
For example, using \code{y ~ .} with default settings means that \code{mfp2()} will
apply FP transformation with 4 df to all continuous variables and use alpha
equal to 0.05 to select functional forms, along with the selection algorithm
with a significance level of 0.05 for all variables.
}

\section{Handling Nonpositive Values (\code{zero} and \code{catzero})}{


The \code{zero} and \code{catzero} options provide mechanisms for handling
covariates with nonpositive values in fractional polynomial (FP) models,
especially when those values have a qualitatively different interpretation
than positive ones.

The \code{zero} argument allows fitting FP models using only the positive
values of a covariate, while treating nonpositive values (e.g., zero or
negative) as exactly zero. This is useful when the relationship between the
covariate and the outcome is expected to begin only above zero. For example,
in modeling the effect of cigarette consumption, nonsmokers (zero cigarettes)
may be fundamentally different from smokers. Instead of applying a constant
shift (e.g., adding 1) to all values before transformation, the \code{zero}
argument allows the model to treat zero values as a separate baseline and
apply FP transformations only to the positive values.

The \code{catzero} argument extends this idea by automatically creating a
binary indicator for whether the covariate is positive. Specifically, for
each covariate where \code{catzero = TRUE}, a binary variable \code{Z} is
created such that:

\code{Z = 1} if the covariate value is zero (x = 0)
\code{Z = 0} if the covariate value is positive (x > 0)

This indicator is  included in the model alongside the transformed version
of the covariate. Both are treated as a single predictor during model
selection (if applicable). This approach captures the potential difference
between having a value of zero and having any positive value, while still
allowing flexible modeling of the positive range.

The \code{spike} argument triggers the spike-at-zero (SAZ) algorithm. When
\code{spike = TRUE}, the binary indicator created by \code{catzero} is
formally evaluated together with the FP terms during model selection. When
\code{spike = FALSE} but \code{catzero = TRUE}, the binary indicator is
included in the model without SAZ testing.

This methodology is based on work by Royston and Sauerbrei (2008, Section 4.15)
and is particularly relevant in epidemiological contexts where exposure may
have a threshold effect.
}

\section{Compatibility with \code{mfp} package}{

\code{mfp2} is an extension of the \code{mfp} package and can be used to reproduce
the results from a model fitted by \code{mfp}. Since both packages implement the
MFP algorithm, they use functions with the same names (e.g \code{fp()}). Therefore,
if you load both packages using a call to \code{library}, there will
be namespace conflicts and only the functions from the package loaded last
will work properly.
}

\section{Convergence and Troubleshooting}{

Typically, \code{mfp2} requires two to four cycles to achieve convergence. Lack of
convergence involves oscillation between two or more models and is extremely
rare. If the model does not converge, you can try changing the nominal
significance levels for variable (\code{select}) or function selection (\code{alpha}).
}

\examples{

# Gaussian model
data("prostate")
x = as.matrix(prostate[,2:8])
y = as.numeric(prostate$lpsa)
# default interface
fit1 = mfp2(x, y, verbose = FALSE)
fit1$fp_terms
fracplot(fit1) # generate plots
summary(fit1)
# formula interface
fit1b = mfp2(lpsa ~ fp(age) + fp(svi, df = 1) + fp(pgg45) + fp(cavol) + fp(weight) +
fp(bph) + fp(cp), data = prostate)

# logistic regression model
data("pima")
xx <- as.matrix(pima[, 2:9])
yy <- as.vector(pima$y)
fit2 <- mfp2(xx, yy, family = "binomial", verbose = FALSE)
fit2$fp_terms

# Cox regression model
data("gbsg")
# create dummy variable for grade using ordinal coding
gbsg <- create_dummy_variables(gbsg, var_ordinal = "grade", drop_variables = TRUE)
xd <- as.matrix(gbsg[, -c(1, 6, 10, 11)])
yd <- survival::Surv(gbsg$rectime, gbsg$censrec)
# fit mfp and keep hormon in the model
fit3 <- mfp2(xd, yd, family = "cox", keep = "hormon", verbose = FALSE)
fit3$fp_terms

}
\references{
Royston, P. and Sauerbrei, W., 2008. \emph{Multivariable Model - Building:
A Pragmatic Approach to Regression Anaylsis based on Fractional Polynomials
for Modelling Continuous Variables. John Wiley & Sons.}\cr

Sauerbrei, W., Meier-Hirmer, C., Benner, A. and Royston, P., 2006.
\emph{Multivariable regression model building by using fractional
polynomials: Description of SAS, STATA and R programs.
Comput Stat Data Anal, 50(12): 3464-85.}\cr

Royston, P. 2014. \emph{A smooth covariate rank transformation for use in
regression models with a sigmoid dose-response function.
Stata Journal 14(2): 329-341.}\cr

Royston, P. and Sauerbrei, W., 2016. \emph{mfpa: Extension of mfp using the
ACD covariate transformation for enhanced parametric multivariable modeling.
The Stata Journal, 16(1), pp.72-87.}\cr

Sauerbrei, W. and Royston, P., 1999. \emph{Building multivariable prognostic
and diagnostic models: transformation of the predictors by using fractional
polynomials. J Roy Stat Soc a Sta, 162:71-94.}\cr

Sauerbrei, W., Kipruto, E. and Balmford, J., 2023. \emph{Effects of influential
points and sample size on the selection and replicability of multivariable
fractional polynomial models. Diagnostic and Prognostic Research, 7(1), p.7.}\cr

Lorenz, E., Jenkner, C., Sauerbrei, W. and Becher, H., 2019. \emph{Modeling exposures
with a spike at zero: simulation study and practical application to survival data.
Biostatistics & Epidemiology, 3(1), pp.23-37.}
}
\seealso{
\code{\link[=summary.mfp2]{summary.mfp2()}}, \code{\link[=coef.mfp2]{coef.mfp2()}}, \code{\link[=predict.mfp2]{predict.mfp2()}}, \code{\link[=fp]{fp()}}
}
